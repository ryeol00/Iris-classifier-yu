# iris-classification 코드 설명 및 느낀 점
CH.2 

2장에서는 Sample, TrainingData,Hyperparameter 세 가지 클래스를 정의한다.
Sample 클래스의 각 인스턴스는 작업 데이터의 핵심 속성이다. 이 예제의 데이터는 아리스의 꽃받침의 길이와 너비, 꽃잎의 길이와 너비를 측정한 것이다.
Sample 클래스 내에는 종의 매우 복잡한 내부 상태를 반영하였으며, 미분류에서 분류로의 상태 변경을 정의하는 classify()메서드와 뷴류결과를 식물학자가 지정한 종과 비교하는 matches()메서드를 정의하고 있다.
TrainingData클래스는 샘플을 로드하고 테스트하는 메서드를 가지며, 학습 및 테스트 데이터셋을 포함한다. 추가로 Hyperparameter에 대한 시도를 기록하기에 적합하다. 
Hyperparameter 클래스는 각 테스트 샘플을 분류한 후 샘플의 classification 속성을 설정한다. 

CH.3

3장에서는 샘플사이의 거리를 구하는 다양한 거리 계산법들을 정의하고 있다.
먼저 Distance 클래스를 정의하여 단순 거리계산에대해 정의한다. 이 기본계산 클래스의 하위클래스로 유클리드,맨해튼,체비쇼프,쇠렌센 거리등을 상속한다.
Distance의 하위클래스
(1) 유클리드 거리 : 가장 익숙한 거리계산법이며 계산에 필요한 제곱 및 제곱근 실행을 위해 math.hypot() 함수 활용
(2) 맨해튼 거리 : x축을 따라가는 총 단계수에 y축을 따라가는 총 단계수를 더한 것이다. 
(3) 체비쇼프 거리 : x 거리의 절대값과 y거리의 절대값 중 가장 큰 거리이며, 여러 차원의 영향을 최소화 하려는 경향이 있다.
(4) 쇠렌센 거리 : 가장 복잡한 거리계산법이며 원점에서 멀리 떨어진 측정값의 중요성을 줄여 값이 큰 이상치가 k-NN을 지배하지 못하도록 한다.
* 추후 Distance 객체는 Hyperparameter 클래스에 통합되어 클래스 내부에서 사용된다.

CH.4 

4장에서는 InvalidSampleError클래스를 정의하여 샘플 객체를 로드할 때 어떤 오류가 발생할 수 있는지 판단 할 수 있다.
또한 KnownSample에 CSV모듈 DictReader클래스의 from_dict() 메서드를 활용하여 종 값을 확인해 유효하지 않은 경우 예외를 발생시킨다.
from_dict() 메서드는 @classmethod 데코레이터와 함께 정의 되어 실제 클래스 객체가 첫 번째 매개변수인 cls가 된다. 이는 상속하는 모든 하위클래스가 해당 하위클래스에 맞게 조정된 메서드를 갖게 된다는 의미이다. 

CH.5 

5장에서는 크게 SampleReader클래스를 활용한 입력 데이터 검증과, Purpose 클래스를 활용한 purpose 열거, @property메서드와 setter를 활용한 프로퍼티 세터로 나뉜다.
다양한 데이터 소스를 지원하려면 입력값을 검증하기 위한 몇 가지 공통 규칙이 필요하고, 따라서 SamplReader 클래스가 필요하다. 
이것은 CSV DictReader 인스턴스가 읽은 입력 필드로부터 Sample 상위 클래스의 인스턴스를 빌드한다. sample_iter() 메서드는 일련의 변환 표현식을 사용해 각 열의 입력 데이터를 파이썬 객체로 변환한다. 이것은 한 묶음의 float()함수를 의미하며 이 함수는 잘못된 데이터를 만나면 ValueError를 발생시켜 데이터의 유효성을 검증한다.
Purpose클래스에서는 Purpose(x)를 사용해 입력값을 Purpose 객체로 변환할 수 있고, 여기서 x는 정수 0,1,2이다. 이외 값은 ValueError 예외를 발생시킨다. 이런 숫자 코드 사용은 파이썬의 열거형 객체를 다루지 않는 외부 소프트웨어와 잘 맞을 수 있다.
classification를 위한 초기의 @property 정의를 "게터"라고 하며 속성 값을 가져온다. 그리고 classification를 위한 또 다른 @property정의는 추가 데코레이터인 @classification.setter를 만들고, setter에 의해 데코레이트된 메서드는 할당문에 사용된다.

CH.6

6장에서는 두개의 하위리스트로 리스트 클래스 확장, 분할을 위한 셔플링과 증분에대한 내용이다.
내장 리스트 클래스를 확장하면 기능을 추가할 수 있다. SamplePartition 클래스에 @overload 데코레이터를 사용하여 __init__()메서드에 대해 두 가지 오버로드를 정의했다. 첫째는 위치 매개변수가 없는 __init__()메서드로 SampleDict 객체의 빈 리스트가 생성된다. 두 번째는 Sampledict 객체의 반복 가능한 소스를 유일한 위치 매개변수로 갖는 __init__() 메서드이다.
ShufflingSamplePartition 클래스에 traing과 testing 두 프로퍼티는 모두 내부 shuffle() 메서드를 사용한다. 이 메서드는 split 속성을 사용해 샘플이 정확히 한 번 섞이도록 하고, 샘플을 학습 및 테스트 하위 집합으로 분할할 위치도 보여준다.
증분은 셔플링과 반대로 난수 생성기에 의존하지 않는 메서드이다.

CH.7

7장에서는 Sample 클래스를 @dateclass로 구현하여 수정하는 작업이다. @dataclass는 일반적으로 가변 객체를 생성하는 것이며, 속성에 새 값을 할당하여 객체의 상태를 변경 할 수도 있다. 이번 작업에서는 고정된 데이터클래스인 @dateclass(frozen = True)를 사용하여 Sample 객체를 고정시켜 거의 동일한 메서드와 속성을 가진 여러 샘플들을 느슨한 클래스 모음으로 형성하여 공통 추상 상위 클래스가 없더라도 상호 호환될 수 있는 구조로 만든다. 이는 최소한의 코드로 풍부한 기능을 제공한다. 추가로 typing.NamedTuple 도 사용하였는데 이것도 @dateclass(frozen = True) 와 유사한 기능을 한다. 허나 명백한 방식으로 상속을 지원하지는 않고 객체의 구성 관계를 기반으로 하는 디자인으로 인도하여 서로 다른 클래스의 여러 부분을 갖는 객체를 생성 한다. 

느낀점

솔직히 1-7장까지 그저 책의 사례연구 코드를 따라치는 것 만으로도 내용이 방대하고 어려워 완전히 이해하는데는 한계가 있었다. 그러나 이번 수업을 듣기전까지는 객체지향 프로그래밍에 대해 아는 것이 전무하였고, 중요도 또한 당연히 몰랐지만 수업과 과제를 통해  객체 지향의 기본 원리와 필요성, 그리고 어떤 언어를 사용하더라도 객체지향적 코딩은 선택이 아닌 필수라는 사실도 크게 느꼈다. 이번 수업을 기점으로 객체지향적 코딩과 개념을 좀 더 공부하고, 연습하여 언젠가 이 책을 완전히 이해하고 직접 코딩할 수 있도록 노력해야겠다고 느꼈다.
